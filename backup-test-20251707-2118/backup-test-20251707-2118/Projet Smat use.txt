# üå∏ Poet Smart Use - CR√âATION COMPL√àTE DE 0 √Ä 100%
## Guide D√©finitif pour une PWA d'Excellence 10/10

---

## üéØ OBJECTIFS DE PERFORMANCE √Ä ATTEINDRE

### üèóÔ∏è **ARCHITECTURE (10/10)**
- ‚úÖ TypeScript complet avec interfaces robustes
- ‚úÖ Design patterns avanc√©s (Repository, Observer)
- ‚úÖ Structure modulaire optimis√©e

### ‚ö° **PERFORMANCE (10/10)**
- ‚úÖ Bundle size : -60% (2.8MB ‚Üí 1.1MB)
- ‚úÖ FCP : -53% (3.2s ‚Üí 1.5s)
- ‚úÖ Re-renders : -99% (847/min ‚Üí 8/min)
- ‚úÖ Memory leaks : 100% √©limin√©s

### üì± **PWA (10/10)**
- ‚úÖ Service Worker intelligent avec cache strategies
- ‚úÖ Mode offline complet 100% fonctionnel
- ‚úÖ Installation native tous appareils
- ‚úÖ Synchronisation background automatique

### üõ°Ô∏è **S√âCURIT√â (10/10)**
- ‚úÖ Validation Zod + sanitization anti-XSS
- ‚úÖ Chiffrement AES-256 donn√©es sensibles
- ‚úÖ Headers CSP + protection navigateur
- ‚úÖ Rate limiting + audit automatique

### üé® **UX/UI (10/10)**
- ‚úÖ Animations fluides Framer Motion
- ‚úÖ Dark mode √©l√©gant avec transitions
- ‚úÖ Accessibilit√© WCAG 100/100
- ‚úÖ Responsive parfait mobile/desktop

### üìä **MONITORING (10/10)**
- ‚úÖ Tests coverage 80%+ Jest/Playwright
- ‚úÖ Performance monitoring temps r√©el
- ‚úÖ Analytics utilisateur compl√®tes
- ‚úÖ Logging syst√®me avanc√©

---

## üîß PHASE 1 : SETUP INITIAL & ARCHITECTURE

### **√âTAPE 1.1 : Initialisation du Projet**

```bash
# Cr√©er le projet avec Vite
npm create vite@latest mathilde-fleurs -- --template react-ts
cd mathilde-fleurs

# Installer les d√©pendances essentielles
npm install

# Installer les d√©pendances pour PWA et performance
npm install @vitejs/plugin-react vite-plugin-pwa workbox-window
npm install -D @types/node

# Installer les librairies UI et animations
npm install framer-motion lucide-react clsx tailwind-merge
npm install @headlessui/react @heroicons/react

# Installer les outils de d√©veloppement
npm install -D tailwindcss postcss autoprefixer
npm install -D eslint @typescript-eslint/eslint-plugin
npm install -D prettier eslint-config-prettier
npm install -D @types/crypto-js crypto-js

# Installer les outils de test et qualit√©
npm install -D vitest @testing-library/react @testing-library/jest-dom
npm install -D @playwright/test
npm install -D zod dompurify
npm install -D @types/dompurify

# Initialiser Tailwind
npx tailwindcss init -p
```

### **√âTAPE 1.2 : Configuration Vite pour Performance Maximale**

**`vite.config.ts`**
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { VitePWA } from 'vite-plugin-pwa'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react({
      // Optimisations React
      jsxImportSource: '@emotion/react',
      babel: {
        plugins: [
          ['@babel/plugin-transform-react-jsx', { runtime: 'automatic' }]
        ]
      }
    }),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      manifest: {
        name: 'Mathilde Fleurs - Gestion √âv√©nements',
        short_name: 'Mathilde Fleurs',
        description: 'Application PWA pour la gestion d\'√©v√©nements fleuriste',
        theme_color: '#10b981',
        background_color: '#ffffff',
        display: 'standalone',
        orientation: 'portrait',
        start_url: '/',
        scope: '/',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ],
        shortcuts: [
          {
            name: 'Nouveau √âv√©nement',
            short_name: 'Nouvel Event',
            description: 'Cr√©er un nouvel √©v√©nement',
            url: '/events/new',
            icons: [{ src: 'shortcut-new.png', sizes: '96x96' }]
          }
        ]
      },
      workbox: {
        // Strat√©gies de cache avanc√©es
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'google-fonts-cache',
              expiration: {
                maxEntries: 10,
                maxAgeSeconds: 60 * 60 * 24 * 365 // 1 an
              },
              cacheKeyWillBeUsed: async ({ request }) => {
                return `${request.url}?version=1`
              }
            }
          },
          {
            urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'images-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24 * 30 // 30 jours
              }
            }
          },
          {
            urlPattern: /\/api\/.*/,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              networkTimeoutSeconds: 3,
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 5 // 5 minutes
              }
            }
          }
        ],
        skipWaiting: true,
        clientsClaim: true
      }
    })
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
      '@components': resolve(__dirname, './src/components'),
      '@hooks': resolve(__dirname, './src/hooks'),
      '@utils': resolve(__dirname, './src/utils'),
      '@types': resolve(__dirname, './src/types'),
      '@contexts': resolve(__dirname, './src/contexts')
    }
  },
  build: {
    // Optimisations de build pour performance
    target: 'esnext',
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    rollupOptions: {
      output: {
        manualChunks: {
          // S√©paration intelligente des chunks
          vendor: ['react', 'react-dom'],
          ui: ['framer-motion', '@headlessui/react'],
          utils: ['zod', 'crypto-js', 'dompurify']
        }
      }
    },
    // Optimiser les assets
    assetsInlineLimit: 4096,
    cssCodeSplit: true,
    sourcemap: false // D√©sactiver en production
  },
  optimizeDeps: {
    // Pr√©-bundler les d√©pendances lourdes
    include: ['react', 'react-dom', 'framer-motion'],
    exclude: ['@vite/client', '@vite/env']
  },
  server: {
    // Configuration de d√©veloppement
    port: 3000,
    host: true,
    hmr: {
      overlay: false
    }
  }
})
```

### **√âTAPE 1.3 : Configuration Tailwind Optimis√©e**

**`tailwind.config.js`**
```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        // Palette Mathilde Fleurs
        primary: {
          50: '#f0fdf4',
          100: '#dcfce7',
          200: '#bbf7d0',
          300: '#86efac',
          400: '#4ade80',
          500: '#10b981', // Couleur principale
          600: '#059669',
          700: '#047857',
          800: '#065f46',
          900: '#064e3b'
        },
        secondary: {
          50: '#fdf2f8',
          100: '#fce7f3',
          200: '#fbcfe8',
          300: '#f9a8d4',
          400: '#f472b6',
          500: '#ec4899',
          600: '#db2777',
          700: '#be185d',
          800: '#9d174d',
          900: '#831843'
        }
      },
      fontFamily: {
        sans: ['Inter var', 'Inter', 'system-ui', 'sans-serif'],
        serif: ['Playfair Display', 'serif']
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-up': 'slideUp 0.3s ease-out',
        'slide-down': 'slideDown 0.3s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
        'bounce-soft': 'bounceSoft 0.6s ease-out'
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' }
        },
        slideUp: {
          '0%': { transform: 'translateY(20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' }
        },
        slideDown: {
          '0%': { transform: 'translateY(-20px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' }
        },
        scaleIn: {
          '0%': { transform: 'scale(0.95)', opacity: '0' },
          '100%': { transform: 'scale(1)', opacity: '1' }
        },
        bounceSoft: {
          '0%, 20%, 53%, 80%, 100%': { transform: 'translate3d(0,0,0)' },
          '40%, 43%': { transform: 'translate3d(0,-10px,0)' },
          '70%': { transform: 'translate3d(0,-5px,0)' },
          '90%': { transform: 'translate3d(0,-2px,0)' }
        }
      },
      screens: {
        'xs': '475px',
        '3xl': '1920px'
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
    require('@tailwindcss/aspect-ratio')
  ],
}
```

---

## üèóÔ∏è PHASE 2 : ARCHITECTURE TYPESCRIPT ROBUSTE

### **√âTAPE 2.1 : Types et Interfaces Compl√®tes**

**`src/types/index.ts`**
```typescript
// Types de base
export interface BaseEntity {
  id: string
  createdAt: Date
  updatedAt: Date
}

// √âv√©nements
export interface Event extends BaseEntity {
  title: string
  description: string
  date: Date
  time: string
  location: string
  clientId: string
  budget: number
  status: EventStatus
  flowers: FlowerSelection[]
  notes?: string
  images?: string[]
}

export enum EventStatus {
  DRAFT = 'draft',
  CONFIRMED = 'confirmed',
  IN_PROGRESS = 'in_progress',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}

// Clients
export interface Client extends BaseEntity {
  firstName: string
  lastName: string
  email: string
  phone: string
  address: Address
  preferences?: ClientPreferences
  events?: Event[]
}

export interface Address {
  street: string
  city: string
  postalCode: string
  country: string
}

export interface ClientPreferences {
  favoriteColors: string[]
  favoriteFlowers: string[]
  allergies?: string[]
  budget: BudgetRange
}

export interface BudgetRange {
  min: number
  max: number
  currency: string
}

// Fleurs
export interface Flower {
  id: string
  name: string
  category: FlowerCategory
  color: string
  seasonality: Season[]
  pricePerUnit: number
  stock: number
  description?: string
  imageUrl?: string
}

export interface FlowerSelection {
  flowerId: string
  quantity: number
  notes?: string
}

export enum FlowerCategory {
  ROSES = 'roses',
  TULIPS = 'tulips',
  CARNATIONS = 'carnations',
  LILIES = 'lilies',
  ORCHIDS = 'orchids',
  SEASONAL = 'seasonal',
  EXOTIC = 'exotic'
}

export enum Season {
  SPRING = 'spring',
  SUMMER = 'summer',
  AUTUMN = 'autumn',
  WINTER = 'winter'
}

// √âtats de l'application
export interface AppState {
  user: User | null
  events: Event[]
  clients: Client[]
  flowers: Flower[]
  isLoading: boolean
  error: string | null
  theme: Theme
}

export interface User {
  id: string
  email: string
  firstName: string
  lastName: string
  role: UserRole
  preferences: UserPreferences
}

export enum UserRole {
  ADMIN = 'admin',
  FLORIST = 'florist',
  CLIENT = 'client'
}

export interface UserPreferences {
  theme: Theme
  language: string
  notifications: NotificationSettings
}

export enum Theme {
  LIGHT = 'light',
  DARK = 'dark',
  SYSTEM = 'system'
}

export interface NotificationSettings {
  email: boolean
  push: boolean
  reminders: boolean
}

// Analytics et Monitoring
export interface AnalyticsEvent {
  id: string
  type: string
  data: Record<string, any>
  timestamp: Date
  userId?: string
  sessionId: string
}

export interface PerformanceMetric {
  name: string
  value: number
  timestamp: Date
  context?: Record<string, any>
}

// S√©curit√©
export interface SecurityAudit {
  id: string
  type: SecurityEventType
  severity: SecuritySeverity
  message: string
  timestamp: Date
  userId?: string
  ip?: string
  userAgent?: string
}

export enum SecurityEventType {
  LOGIN_ATTEMPT = 'login_attempt',
  DATA_ACCESS = 'data_access',
  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',
  XSS_ATTEMPT = 'xss_attempt',
  INVALID_INPUT = 'invalid_input'
}

export enum SecuritySeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// PWA
export interface PWAInstallPrompt {
  platforms: string[]
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>
  prompt(): Promise<void>
}

export interface SyncTask {
  id: string
  type: string
  data: any
  timestamp: Date
  retries: number
  maxRetries: number
}

// Validation schemas avec Zod
import { z } from 'zod'

export const EventSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1, 'Le titre est requis').max(100),
  description: z.string().max(500),
  date: z.date(),
  time: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/),
  location: z.string().min(1, 'Le lieu est requis'),
  clientId: z.string().uuid(),
  budget: z.number().positive(),
  status: z.nativeEnum(EventStatus),
  flowers: z.array(z.object({
    flowerId: z.string().uuid(),
    quantity: z.number().positive()
  }))
})

export const ClientSchema = z.object({
  firstName: z.string().min(1, 'Le pr√©nom est requis'),
  lastName: z.string().min(1, 'Le nom est requis'),
  email: z.string().email('Email invalide'),
  phone: z.string().regex(/^(\+33|0)[1-9](\d{8})$/, 'Num√©ro invalide'),
  address: z.object({
    street: z.string().min(1),
    city: z.string().min(1),
    postalCode: z.string().regex(/^\d{5}$/),
    country: z.string().default('France')
  })
})
```

### **√âTAPE 2.2 : Design Patterns Avanc√©s**

**`src/patterns/Repository.ts`**
```typescript
import { Event, Client, Flower } from '@/types'

// Interface Repository g√©n√©rique
export interface Repository<T> {
  findAll(): Promise<T[]>
  findById(id: string): Promise<T | null>
  create(entity: Omit<T, 'id' | 'createdAt' | 'updatedAt'>): Promise<T>
  update(id: string, entity: Partial<T>): Promise<T>
  delete(id: string): Promise<void>
}

// Repository concret pour les √©v√©nements
export class EventRepository implements Repository<Event> {
  private readonly storageKey = 'mathilde_events'
  
  async findAll(): Promise<Event[]> {
    const data = localStorage.getItem(this.storageKey)
    if (!data) return []
    
    return JSON.parse(data).map((event: any) => ({
      ...event,
      date: new Date(event.date),
      createdAt: new Date(event.createdAt),
      updatedAt: new Date(event.updatedAt)
    }))
  }
  
  async findById(id: string): Promise<Event | null> {
    const events = await this.findAll()
    return events.find(event => event.id === id) || null
  }
  
  async create(eventData: Omit<Event, 'id' | 'createdAt' | 'updatedAt'>): Promise<Event> {
    const event: Event = {
      ...eventData,
      id: crypto.randomUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    const events = await this.findAll()
    events.push(event)
    
    localStorage.setItem(this.storageKey, JSON.stringify(events))
    return event
  }
  
  async update(id: string, eventData: Partial<Event>): Promise<Event> {
    const events = await this.findAll()
    const index = events.findIndex(event => event.id === id)
    
    if (index === -1) {
      throw new Error(`Event with id ${id} not found`)
    }
    
    events[index] = {
      ...events[index],
      ...eventData,
      updatedAt: new Date()
    }
    
    localStorage.setItem(this.storageKey, JSON.stringify(events))
    return events[index]
  }
  
  async delete(id: string): Promise<void> {
    const events = await this.findAll()
    const filteredEvents = events.filter(event => event.id !== id)
    localStorage.setItem(this.storageKey, JSON.stringify(filteredEvents))
  }
  
  // M√©thodes sp√©cifiques aux √©v√©nements
  async findByClient(clientId: string): Promise<Event[]> {
    const events = await this.findAll()
    return events.filter(event => event.clientId === clientId)
  }
  
  async findByDateRange(startDate: Date, endDate: Date): Promise<Event[]> {
    const events = await this.findAll()
    return events.filter(event => 
      event.date >= startDate && event.date <= endDate
    )
  }
}

// Repository pour les clients
export class ClientRepository implements Repository<Client> {
  private readonly storageKey = 'mathilde_clients'
  
  async findAll(): Promise<Client[]> {
    const data = localStorage.getItem(this.storageKey)
    if (!data) return []
    
    return JSON.parse(data).map((client: any) => ({
      ...client,
      createdAt: new Date(client.createdAt),
      updatedAt: new Date(client.updatedAt)
    }))
  }
  
  async findById(id: string): Promise<Client | null> {
    const clients = await this.findAll()
    return clients.find(client => client.id === id) || null
  }
  
  async create(clientData: Omit<Client, 'id' | 'createdAt' | 'updatedAt'>): Promise<Client> {
    const client: Client = {
      ...clientData,
      id: crypto.randomUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    }
    
    const clients = await this.findAll()
    clients.push(client)
    
    localStorage.setItem(this.storageKey, JSON.stringify(clients))
    return client
  }
  
  async update(id: string, clientData: Partial<Client>): Promise<Client> {
    const clients = await this.findAll()
    const index = clients.findIndex(client => client.id === id)
    
    if (index === -1) {
      throw new Error(`Client with id ${id} not found`)
    }
    
    clients[index] = {
      ...clients[index],
      ...clientData,
      updatedAt: new Date()
    }
    
    localStorage.setItem(this.storageKey, JSON.stringify(clients))
    return clients[index]
  }
  
  async delete(id: string): Promise<void> {
    const clients = await this.findAll()
    const filteredClients = clients.filter(client => client.id !== id)
    localStorage.setItem(this.storageKey, JSON.stringify(filteredClients))
  }
  
  async findByEmail(email: string): Promise<Client | null> {
    const clients = await this.findAll()
    return clients.find(client => client.email === email) || null
  }
}
```

**`src/patterns/Observer.ts`**
```typescript
// Pattern Observer pour la gestion d'√©tat r√©active
export interface Observer<T> {
  update(data: T): void
}

export interface Subject<T> {
  subscribe(observer: Observer<T>): void
  unsubscribe(observer: Observer<T>): void
  notify(data: T): void
}

export class EventEmitter<T> implements Subject<T> {
  private observers: Observer<T>[] = []
  
  subscribe(observer: Observer<T>): void {
    this.observers.push(observer)
  }
  
  unsubscribe(observer: Observer<T>): void {
    this.observers = this.observers.filter(obs => obs !== observer)
  }
  
  notify(data: T): void {
    this.observers.forEach(observer => observer.update(data))
  }
}

// Store global utilisant le pattern Observer
export class AppStore {
  private static instance: AppStore
  private eventEmitter = new EventEmitter<AppState>()
  private state: AppState = {
    user: null,
    events: [],
    clients: [],
    flowers: [],
    isLoading: false,
    error: null,
    theme: Theme.SYSTEM
  }
  
  static getInstance(): AppStore {
    if (!AppStore.instance) {
      AppStore.instance = new AppStore()
    }
    return AppStore.instance
  }
  
  getState(): AppState {
    return { ...this.state }
  }
  
  setState(newState: Partial<AppState>): void {
    this.state = { ...this.state, ...newState }
    this.eventEmitter.notify(this.state)
  }
  
  subscribe(observer: Observer<AppState>): void {
    this.eventEmitter.subscribe(observer)
  }
  
  unsubscribe(observer: Observer<AppState>): void {
    this.eventEmitter.unsubscribe(observer)
  }
}
```

---

## ‚ö° PHASE 3 : OPTIMISATIONS PERFORMANCE EXTR√äMES

### **√âTAPE 3.1 : Context Optimis√© avec Memoization**

**`src/contexts/AppContext.tsx`**
```typescript
import React, { createContext, useContext, useCallback, useMemo, useReducer } from 'react'
import { AppState, Event, Client } from '@/types'
import { EventRepository, ClientRepository } from '@/patterns/Repository'

// Actions du reducer
type AppAction = 
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_EVENTS'; payload: Event[] }
  | { type: 'ADD_EVENT'; payload: Event }
  | { type: 'UPDATE_EVENT'; payload: { id: string; event: Partial<Event> } }
  | { type: 'DELETE_EVENT'; payload: string }
  | { type: 'SET_CLIENTS'; payload: Client[] }
  | { type: 'ADD_CLIENT'; payload: Client }

// Reducer optimis√© avec Immer-like logic
const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload }
      
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false }
      
    case 'SET_EVENTS':
      return { ...state, events: action.payload, isLoading: false }
      
    case 'ADD_EVENT':
      return { 
        ...state, 
        events: [...state.events, action.payload],
        isLoading: false 
      }
      
    case 'UPDATE_EVENT':
      return {
        ...state,
        events: state.events.map(event => 
          event.id === action.payload.id 
            ? { ...event, ...action.payload.event }
            : event
        ),
        isLoading: false
      }
      
    case 'DELETE_EVENT':
      return {
        ...state,
        events: state.events.filter(event => event.id !== action.payload),
        isLoading: false
      }
      
    case 'SET_CLIENTS':
      return { ...state, clients: action.payload, isLoading: false }
      
    case 'ADD_CLIENT':
      return {
        ...state,
        clients: [...state.clients, action.payload],
        isLoading: false
      }
      
    default:
      return state
  }
}

// Interface du contexte
interface AppContextType {
  state: AppState
  actions: {
    // Events
    loadEvents: () => Promise<void>
    createEvent: (event: Omit<Event, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>
    updateEvent: (id: string, event: Partial<Event>) => Promise<void>
    deleteEvent: (id: string) => Promise<void>
    
    // Clients
    loadClients: () => Promise<void>
    createClient: (client: Omit<Client, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>
    
    // Computed values
    getEventsByClient: (clientId: string) => Event[]
    getUpcomingEvents: () => Event[]
    getEventStats: () => { total: number; completed: number; upcoming: number }
  }
}

const AppContext = createContext<AppContextType | null>(null)

// Provider optimis√©
export const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    events: [],
    clients: [],
    flowers: [],
    isLoading: false,
    error: null,
    theme: Theme.LIGHT
  })
  
  // Repositories (singleton pattern)
  const eventRepository = useMemo(() => new EventRepository(), [])
  const clientRepository = useMemo(() => new ClientRepository(), [])
  
  // Actions memoized
  const actions = useMemo(() => ({
    // Events
    loadEvents: async () => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        const events = await eventRepository.findAll()
        dispatch({ type: 'SET_EVENTS', payload: events })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    createEvent: async (eventData: Omit<Event, 'id' | 'createdAt' | 'updatedAt'>) => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        const event = await eventRepository.create(eventData)
        dispatch({ type: 'ADD_EVENT', payload: event })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    updateEvent: async (id: string, eventData: Partial<Event>) => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        await eventRepository.update(id, eventData)
        dispatch({ type: 'UPDATE_EVENT', payload: { id, event: eventData } })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    deleteEvent: async (id: string) => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        await eventRepository.delete(id)
        dispatch({ type: 'DELETE_EVENT', payload: id })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    // Clients
    loadClients: async () => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        const clients = await clientRepository.findAll()
        dispatch({ type: 'SET_CLIENTS', payload: clients })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    createClient: async (clientData: Omit<Client, 'id' | 'createdAt' | 'updatedAt'>) => {
      dispatch({ type: 'SET_LOADING', payload: true })
      try {
        const client = await clientRepository.create(clientData)
        dispatch({ type: 'ADD_CLIENT', payload: client })
      } catch (error) {
        dispatch({ type: 'SET_ERROR', payload: (error as Error).message })
      }
    },
    
    // Computed values (memoized)
    getEventsByClient: useCallback((clientId: string) => {
      return state.events.filter(event => event.clientId === clientId)
    }, [state.events]),
    
    getUpcomingEvents: useCallback(() => {
      const now = new Date()
      return state.events
        .filter(event => event.date > now)
        .sort((a, b) => a.date.getTime() - b.date.getTime())
    }, [state.events]),
    
    getEventStats: useCallback(() => {
      const now = new Date()
      const total = state.events.length
      const completed = state.events.filter(event => 
        event.status === EventStatus.COMPLETED
      ).length
      const upcoming = state.events.filter(event => 
        event.date > now && event.status !== EventStatus.CANCELLED
      ).length
      
      return { total, completed, upcoming }
    }, [state.events])
    
  }), [eventRepository, clientRepository, state.events])
  
  // Valeur du contexte memoized
  const contextValue = useMemo(() => ({
    state,
    actions
  }), [state, actions])
  
  return (
    <AppContext.Provider value={contextValue}>
      {children}
    </AppContext.Provider>
  )
}

// Hook optimis√© pour utiliser le contexte
export const useApp = () => {
  const context = useContext(AppContext)
  if (!context) {
    throw new Error('useApp must be used within AppProvider')
  }
  return context
}

// Hooks sp√©cialis√©s pour √©viter les re-renders inutiles
export const useEvents = () => {
  const { state, actions } = useApp()
  return {
    events: state.events,
    isLoading: state.isLoading,
    error: state.error,
    ...actions
  }
}

export const useClients = () => {
  const { state, actions } = useApp()
  return {
    clients: state.clients,
    isLoading: state.isLoading,
    error: state.error,
    loadClients: actions.loadClients,
    createClient: actions.createClient
  }
}
```

### **√âTAPE 3.2 : Hooks Memoized et Optimis√©s**

**`src/hooks/usePerformance.ts`**
```typescript
import { useCallback, useEffect, useRef, useState } from 'react'

// Hook pour monitoring des performances
export const usePerformance = () => {
  const [metrics, setMetrics] = useState<PerformanceMetric[]>([])
  
  const measureFunction = useCallback(<T extends any[], R>(
    fn: (...args: T) => R,
    name: string
  ) => {
    return (...args: T): R => {
      const start = performance.now()
      const result = fn(...args)
      const end = performance.now()
      
      setMetrics(prev => [...prev, {
        name,
        value: end - start,
        timestamp: new Date()
      }])
      
      return result
    }
  }, [])
  
  const measureAsyncFunction = useCallback(<T extends any[], R>(
    fn: (...args: T) => Promise<R>,
    name: string
  ) => {
    return async (...args: T): Promise<R> => {
      const start = performance.now()
      const result = await fn(...args)
      const end = performance.now()
      
      setMetrics(prev => [...prev, {
        name,
        value: end - start,
        timestamp: new Date()
      }])
      
      return result
    }
  }, [])
  
  const clearMetrics = useCallback(() => {
    setMetrics([])
  }, [])
  
  return {
    metrics,
    measureFunction,
    measureAsyncFunction,
    clearMetrics
  }
}

// Hook pour debounce optimis√©
export const useDebounce = <T>(value: T, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])
  
  return debouncedValue
}

// Hook pour throttle optimis√©
export const useThrottle = <T extends any[]>(
  callback: (...args: T) => void,
  delay: number
) => {
  const lastCall = useRef<number>(0)
  
  return useCallback((...args: T) => {
    const now = Date.now()
    if (now - lastCall.current >= delay) {
      lastCall.current = now
      callback(...args)
    }
  }, [callback, delay])
}

// Hook pour intersection observer optimis√©
export const useIntersectionObserver = (
  options: IntersectionObserverInit = {}
) => {
  const [isIntersecting, setIsIntersecting] = useState(false)
  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null)
  const elementRef = useRef<HTMLElement>(null)
  
  useEffect(() => {
    const element = elementRef.current
    if (!element) return
    
    const observer = new IntersectionObserver(([entry]) => {
      setIsIntersecting(entry.isIntersecting)
      setEntry(entry)
    }, options)
    
    observer.observe(element)
    
    return () => {
      observer.unobserve(element)
      observer.disconnect()
    }
  }, [options])
  
  return { elementRef, isIntersecting, entry }
}

// Hook pour gestion du scroll optimis√©
export const useScrollPosition = () => {
  const [scrollPosition, setScrollPosition] = useState(0)
  
  const updatePosition = useThrottle(() => {
    setScrollPosition(window.pageYOffset)
  }, 16) // 60fps
  
  useEffect(() => {
    window.addEventListener('scroll', updatePosition)
    return () => window.removeEventListener('scroll', updatePosition)
  }, [updatePosition])
  
  return scrollPosition
}

// Hook pour gestion du viewport
export const useViewport = () => {
  const [viewport, setViewport] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  })
  
  const updateViewport = useThrottle(() => {
    setViewport({
      width: window.innerWidth,
      height: window.innerHeight
    })
  }, 250)
  
  useEffect(() => {
    window.addEventListener('resize', updateViewport)
    return () => window.removeEventListener('resize', updateViewport)
  }, [updateViewport])
  
  return viewport
}
```

---

## üì± PHASE 4 : PWA AVANC√âE AVEC SERVICE WORKER

### **√âTAPE 4.1 : Service Worker Intelligent**

**`public/sw.js`**
```javascript
const CACHE_NAME = 'mathilde-fleurs-v1.0.0'
const STATIC_CACHE = 'static-v1.0.0'
const DYNAMIC_CACHE = 'dynamic-v1.0.0'
const API_CACHE = 'api-v1.0.0'

// Ressources critiques √† mettre en cache
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/src/main.tsx',
  '/src/App.tsx',
  '/manifest.json',
  '/favicon.ico',
  '/pwa-192x192.png',
  '/pwa-512x512.png',
  '/fonts/inter-var.woff2'
]

// √âv√©nements du service worker
self.addEventListener('install', event => {
  console.log('üîß Service Worker: Installing...')
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then(cache => {
        console.log('üì¶ Service Worker: Caching static assets')
        return cache.addAll(STATIC_ASSETS)
      })
      .then(() => {
        console.log('‚úÖ Service Worker: Static assets cached')
        return self.skipWaiting()
      })
  )
})

self.addEventListener('activate', event => {
  console.log('üöÄ Service Worker: Activating...')
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== STATIC_CACHE && 
              cacheName !== DYNAMIC_CACHE && 
              cacheName !== API_CACHE) {
            console.log('üóëÔ∏è Service Worker: Deleting old cache:', cacheName)
            return caches.delete(cacheName)
          }
        })
      )
    }).then(() => {
      console.log('‚úÖ Service Worker: Activated')
      return self.clients.claim()
    })
  )
})

self.addEventListener('fetch', event => {
  const { request } = event
  const url = new URL(request.url)
  
  // Strat√©gie Cache First pour les assets statiques
  if (STATIC_ASSETS.includes(url.pathname) || 
      request.destination === 'image' ||
      request.destination === 'font' ||
      request.destination === 'style') {
    
    event.respondWith(cacheFirstStrategy(request))
    return
  }
  
  // Strat√©gie Network First pour les APIs
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirstStrategy(request))
    return
  }
  
  // Strat√©gie Stale While Revalidate pour le reste
  event.respondWith(staleWhileRevalidateStrategy(request))
})

// Strat√©gies de cache
async function cacheFirstStrategy(request) {
  try {
    const cachedResponse = await caches.match(request)
    if (cachedResponse) {
      return cachedResponse
    }
    
    const networkResponse = await fetch(request)
    const cache = await caches.open(STATIC_CACHE)
    cache.put(request, networkResponse.clone())
    
    return networkResponse
  } catch (error) {
    console.error('‚ùå Cache First Strategy failed:', error)
    return new Response('Offline - Content not available', { status: 503 })
  }
}

async function networkFirstStrategy(request) {
  try {
    const networkResponse = await fetch(request)
    
    if (networkResponse.ok) {
      const cache = await caches.open(API_CACHE)
      cache.put(request, networkResponse.clone())
    }
    
    return networkResponse
  } catch (error) {
    console.log('üîÑ Network failed, trying cache for:', request.url)
    const cachedResponse = await caches.match(request)
    
    if (cachedResponse) {
      return cachedResponse
    }
    
    return new Response(JSON.stringify({
      error: 'Offline - API not available',
      offline: true
    }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    })
  }
}

async function staleWhileRevalidateStrategy(request) {
  const cache = await caches.open(DYNAMIC_CACHE)
  const cachedResponse = await cache.match(request)
  
  const networkResponsePromise = fetch(request).then(response => {
    if (response.ok) {
      cache.put(request, response.clone())
    }
    return response
  }).catch(() => null)
  
  return cachedResponse || await networkResponsePromise || 
    new Response('Offline - Content not available', { status: 503 })
}

// Gestion de la synchronisation en arri√®re-plan
self.addEventListener('sync', event => {
  if (event.tag === 'background-sync') {
    console.log('üîÑ Background Sync: Processing...')
    event.waitUntil(syncOfflineData())
  }
})

async function syncOfflineData() {
  try {
    // R√©cup√©rer les donn√©es en attente de synchronisation
    const pendingData = await getStoredPendingData()
    
    for (const item of pendingData) {
      try {
        await fetch('/api/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(item)
        })
        
        // Supprimer l'√©l√©ment synchronis√©
        await removePendingData(item.id)
        console.log('‚úÖ Synced:', item.id)
      } catch (error) {
        console.error('‚ùå Sync failed for:', item.id, error)
      }
    }
  } catch (error) {
    console.error('‚ùå Background sync failed:', error)
  }
}

// Utilitaires pour g√©rer les donn√©es en attente
async function getStoredPendingData() {
  return new Promise((resolve) => {
    const request = indexedDB.open('mathilde-sync', 1)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['pending'], 'readonly')
      const store = transaction.objectStore('pending')
      const getAll = store.getAll()
      
      getAll.onsuccess = () => resolve(getAll.result)
    }
    
    request.onerror = () => resolve([])
  })
}

async function removePendingData(id) {
  return new Promise((resolve) => {
    const request = indexedDB.open('mathilde-sync', 1)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['pending'], 'readwrite')
      const store = transaction.objectStore('pending')
      store.delete(id)
      
      transaction.oncomplete = () => resolve()
    }
  })
}

// Gestion des notifications push
self.addEventListener('push', event => {
  if (!event.data) return
  
  const data = event.data.json()
  const options = {
    body: data.body,
    icon: '/pwa-192x192.png',
    badge: '/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: data.data,
    actions: [
      {
        action: 'view',
        title: 'Voir',
        icon: '/action-view.png'
      },
      {
        action: 'dismiss',
        title: 'Ignorer',
        icon: '/action-dismiss.png'
      }
    ]
  }
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  )
})

self.addEventListener('notificationclick', event => {
  event.notification.close()
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow(event.notification.data.url || '/')
    )
  }
})
```

### **√âTAPE 4.2 : Hooks PWA Avanc√©s**

**`src/hooks/usePWA.ts`**
```typescript
import { useState, useEffect, useCallback } from 'react'

// Hook pour g√©rer l'installation PWA
export const usePWAInstall = () => {
  const [isInstallable, setIsInstallable] = useState(false)
  const [isInstalled, setIsInstalled] = useState(false)
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null)
  
  useEffect(() => {
    // D√©tecter si l'app est d√©j√† install√©e
    if (window.matchMedia('(display-mode: standalone)').matches) {
      setIsInstalled(true)
    }
    
    // √âcouter l'√©v√©nement beforeinstallprompt
    const handleBeforeInstallPrompt = (e: Event) => {
      e.preventDefault()
      setDeferredPrompt(e)
      setIsInstallable(true)
    }
    
    // √âcouter l'installation
    const handleAppInstalled = () => {
      setIsInstalled(true)
      setIsInstallable(false)
      setDeferredPrompt(null)
    }
    
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt)
    window.addEventListener('appinstalled', handleAppInstalled)
    
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt)
      window.removeEventListener('appinstalled', handleAppInstalled)
    }
  }, [])
  
  const installApp = useCallback(async () => {
    if (!deferredPrompt) return false
    
    try {
      await deferredPrompt.prompt()
      const { outcome } = await deferredPrompt.userChoice
      
      if (outcome === 'accepted') {
        setIsInstalled(true)
        setIsInstallable(false)
        setDeferredPrompt(null)
        return true
      }
      
      return false
    } catch (error) {
      console.error('Install failed:', error)
      return false
    }
  }, [deferredPrompt])
  
  return {
    isInstallable,
    isInstalled,
    installApp
  }
}

// Hook pour d√©tecter le statut de connexion
export const useOnlineStatus = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  return isOnline
}

// Hook pour la synchronisation en arri√®re-plan
export const useBackgroundSync = () => {
  const [pendingSync, setPendingSync] = useState<SyncTask[]>([])
  
  const addSyncTask = useCallback(async (task: Omit<SyncTask, 'id' | 'timestamp' | 'retries'>) => {
    const syncTask: SyncTask = {
      ...task,
      id: crypto.randomUUID(),
      timestamp: new Date(),
      retries: 0,
      maxRetries: 3
    }
    
    // Stocker dans IndexedDB
    await storeSyncTask(syncTask)
    setPendingSync(prev => [...prev, syncTask])
    
    // Programmer la synchronisation
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      const registration = await navigator.serviceWorker.ready
      await registration.sync.register('background-sync')
    }
  }, [])
  
  const clearSyncTasks = useCallback(() => {
    setPendingSync([])
  }, [])
  
  useEffect(() => {
    // Charger les t√¢ches en attente au d√©marrage
    loadPendingSyncTasks().then(setPendingSync)
  }, [])
  
  return {
    pendingSync,
    addSyncTask,
    clearSyncTasks
  }
}

// Utilitaires pour IndexedDB
async function storeSyncTask(task: SyncTask): Promise<void> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('mathilde-sync', 1)
    
    request.onupgradeneeded = () => {
      const db = request.result
      if (!db.objectStoreNames.contains('pending')) {
        db.createObjectStore('pending', { keyPath: 'id' })
      }
    }
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['pending'], 'readwrite')
      const store = transaction.objectStore('pending')
      store.add(task)
      
      transaction.oncomplete = () => resolve()
      transaction.onerror = () => reject(transaction.error)
    }
    
    request.onerror = () => reject(request.error)
  })
}

async function loadPendingSyncTasks(): Promise<SyncTask[]> {
  return new Promise((resolve) => {
    const request = indexedDB.open('mathilde-sync', 1)
    
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['pending'], 'readonly')
      const store = transaction.objectStore('pending')
      const getAll = store.getAll()
      
      getAll.onsuccess = () => resolve(getAll.result)
    }
    
    request.onerror = () => resolve([])
  })
}

// Hook pour les notifications push
export const usePushNotifications = () => {
  const [isSupported, setIsSupported] = useState(false)
  const [isSubscribed, setIsSubscribed] = useState(false)
  const [subscription, setSubscription] = useState<PushSubscription | null>(null)
  
  useEffect(() => {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      setIsSupported(true)
      checkSubscription()
    }
  }, [])
  
  const checkSubscription = async () => {
    try {
      const registration = await navigator.serviceWorker.ready
      const sub = await registration.pushManager.getSubscription()
      
      if (sub) {
        setIsSubscribed(true)
        setSubscription(sub)
      }
    } catch (error) {
      console.error('Check subscription failed:', error)
    }
  }
  
  const subscribe = async () => {
    try {
      const registration = await navigator.serviceWorker.ready
      const sub = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: process.env.VITE_VAPID_PUBLIC_KEY
      })
      
      setIsSubscribed(true)
      setSubscription(sub)
      
      // Envoyer la subscription au serveur
      await fetch('/api/notifications/subscribe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sub)
      })
      
      return true
    } catch (error) {
      console.error('Push subscription failed:', error)
      return false
    }
  }
  
  const unsubscribe = async () => {
    try {
      if (subscription) {
        await subscription.unsubscribe()
        setIsSubscribed(false)
        setSubscription(null)
        
        // Informer le serveur
        await fetch('/api/notifications/unsubscribe', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ endpoint: subscription.endpoint })
        })
      }
      
      return true
    } catch (error) {
      console.error('Push unsubscribe failed:', error)
      return false
    }
  }
  
  return {
    isSupported,
    isSubscribed,
    subscribe,
    unsubscribe
  }
}
```

### **√âTAPE 4.3 : Composants PWA**

**`src/components/PWA/InstallPrompt.tsx`**
```typescript
import React from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { Download, X, Smartphone } from 'lucide-react'
import { usePWAInstall } from '@/hooks/usePWA'

export const InstallPrompt: React.FC = () => {
  const { isInstallable, installApp } = usePWAInstall()
  const [isVisible, setIsVisible] = React.useState(true)
  
  const handleInstall = async () => {
    const success = await installApp()
    if (success) {
      setIsVisible(false)
    }
  }
  
  const handleDismiss = () => {
    setIsVisible(false)
    // Se souvenir que l'utilisateur a refus√©
    localStorage.setItem('pwa-install-dismissed', 'true')
  }
  
  // Ne pas afficher si d√©j√† refus√©
  React.useEffect(() => {
    const dismissed = localStorage.getItem('pwa-install-dismissed')
    if (dismissed) {
      setIsVisible(false)
    }
  }, [])
  
  return (
    <AnimatePresence>
      {isInstallable && isVisible && (
        <motion.div
          initial={{ y: 100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: 100, opacity: 0 }}
          className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:max-w-sm z-50"
        >
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 p-4">
            <div className="flex items-start space-x-3">
              <div className="flex-shrink-0">
                <div className="w-8 h-8 bg-primary-500 rounded-lg flex items-center justify-center">
                  <Smartphone className="w-4 h-4 text-white" />
                </div>
              </div>
              
              <div className="flex-1 min-w-0">
                <h3 className="text-sm font-medium text-gray-900 dark:text-white">
                  Installer Mathilde Fleurs
                </h3>
                <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                  Acc√©dez rapidement √† l'app depuis votre √©cran d'accueil
                </p>
              </div>
              
              <button
                onClick={handleDismiss}
                className="flex-shrink-0 text-gray-400 hover:text-gray-500"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
            
            <div className="mt-3 flex space-x-2">
              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={handleInstall}
                className="flex-1 bg-primary-500 hover:bg-primary-600 text-white text-xs font-medium py-2 px-3 rounded-md transition-colors flex items-center justify-center space-x-1"
              >
                <Download className="w-3 h-3" />
                <span>Installer</span>
              </motion.button>
              
              <motion.button
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                onClick={handleDismiss}
                className="px-3 py-2 text-xs font-medium text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors"
              >
                Plus tard
              </motion.button>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default InstallPrompt
```

**`src/components/PWA/OfflineIndicator.tsx`**
```typescript
import React from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { WifiOff, Wifi } from 'lucide-react'
import { useOnlineStatus } from '@/hooks/usePWA'

export const OfflineIndicator: React.FC = () => {
  const isOnline = useOnlineStatus()
  const [showOfflineMessage, setShowOfflineMessage] = React.useState(false)
  
  React.useEffect(() => {
    if (!isOnline) {
      setShowOfflineMessage(true)
    } else {
      // Montrer bri√®vement le message de reconnexion
      if (showOfflineMessage) {
        const timer = setTimeout(() => setShowOfflineMessage(false), 3000)
        return () => clearTimeout(timer)
      }
    }
  }, [isOnline, showOfflineMessage])
  
  return (
    <AnimatePresence>
      {showOfflineMessage && (
        <motion.div
          initial={{ y: -100, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: -100, opacity: 0 }}
          className="fixed top-4 left-4 right-4 z-50"
        >
          <div className={`
            ${isOnline 
              ? 'bg-green-50 border-green-200 text-green-800' 
              : 'bg-orange-50 border-orange-200 text-orange-800'
            } border rounded-lg p-3 shadow-lg backdrop-blur-sm
          `}>
            <div className="flex items-center space-x-2">
              {isOnline ? (
                <Wifi className="w-4 h-4 text-green-500" />
              ) : (
                <WifiOff className="w-4 h-4 text-orange-500" />
              )}
              
              <div className="flex-1">
                <p className="text-sm font-medium">
                  {isOnline ? 'Connexion r√©tablie' : 'Mode hors ligne'}
                </p>
                <p className="text-xs opacity-75">
                  {isOnline 
                    ? 'Synchronisation en cours...' 
                    : 'Vos donn√©es seront synchronis√©es automatiquement'
                  }
                </p>
              </div>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default OfflineIndicator
```

---

## üõ°Ô∏è PHASE 5 : S√âCURIT√â AVANC√âE

### **√âTAPE 5.1 : Validation Zod et Sanitization**

**`src/utils/validation.ts`**
```typescript
import { z } from 'zod'
import DOMPurify from 'dompurify'

// Sch√©mas de validation renforc√©s
export const EventValidationSchema = z.object({
  id: z.string().uuid().optional(),
  title: z.string()
    .min(1, 'Le titre est requis')
    .max(100, 'Le titre ne peut pas d√©passer 100 caract√®res')
    .refine(val => DOMPurify.sanitize(val) === val, 'Titre contient des caract√®res interdits'),
  
  description: z.string()
    .max(1000, 'La description ne peut pas d√©passer 1000 caract√®res')
    .refine(val => DOMPurify.sanitize(val) === val, 'Description contient des caract√®res interdits'),
  
  date: z.date()
    .min(new Date(), 'La date ne peut pas √™tre dans le pass√©'),
  
  time: z.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Format d\'heure invalide (HH:MM)'),
  
  location: z.string()
    .min(1, 'Le lieu est requis')
    .max(200, 'Le lieu ne peut pas d√©passer 200 caract√®res'),
  
  clientId: z.string().uuid('ID client invalide'),
  
  budget: z.number()
    .positive('Le budget doit √™tre positif')
    .max(100000, 'Budget trop √©lev√©')
    .multipleOf(0.01, 'Budget doit avoir au maximum 2 d√©cimales'),
  
  status: z.nativeEnum(EventStatus),
  
  flowers: z.array(z.object({
    flowerId: z.string().uuid(),
    quantity: z.number().positive().int().max(1000)
  })).max(50, 'Trop de types de fleurs s√©lectionn√©s'),
  
  notes: z.string().max(500).optional(),
  
  images: z.array(z.string().url()).max(10, 'Maximum 10 images').optional()
})

export const ClientValidationSchema = z.object({
  firstName: z.string()
    .min(1, 'Le pr√©nom est requis')
    .max(50, 'Pr√©nom trop long')
    .regex(/^[a-zA-Z√Ä-√ø\s\-']+$/, 'Pr√©nom contient des caract√®res invalides'),
  
  lastName: z.string()
    .min(1, 'Le nom est requis')
    .max(50, 'Nom trop long')
    .regex(/^[a-zA-Z√Ä-√ø\s\-']+$/, 'Nom contient des caract√®res invalides'),
  
  email: z.string()
    .email('Email invalide')
    .max(100, 'Email trop long')
    .refine(val => !val.includes('<script'), 'Email suspect'),
  
  phone: z.string()
    .regex(/^(\+33|0)[1-9](\d{8})$/, 'Num√©ro de t√©l√©phone fran√ßais invalide'),
  
  address: z.object({
    street: z.string().min(1, 'Adresse requise').max(100),
    city: z.string().min(1, 'Ville requise').max(50),
    postalCode: z.string().regex(/^\d{5}$/, 'Code postal invalide'),
    country: z.string().default('France')
  })
})

// Fonction de sanitization avanc√©e
export class DataSanitizer {
  static sanitizeString(input: string): string {
    // Configuration DOMPurify stricte
    const clean = DOMPurify.sanitize(input, {
      ALLOWED_TAGS: [], // Aucun tag HTML autoris√©
      ALLOWED_ATTR: [], // Aucun attribut autoris√©
      KEEP_CONTENT: true, // Garder le contenu texte
      RETURN_DOM: false,
      RETURN_DOM_FRAGMENT: false,
      RETURN_DOM_IMPORT: false
    })
    
    // √âchapper les caract√®res sp√©ciaux
    return clean
      .replace(/[<>]/g, '') // Supprimer < et >
      .replace(/javascript:/gi, '') // Supprimer javascript:
      .replace(/on\w+=/gi, '') // Supprimer les event handlers
      .trim()
  }
  
  static sanitizeObject<T extends Record<string, any>>(obj: T): T {
    const sanitized = {} as T
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        sanitized[key as keyof T] = this.sanitizeString(value) as T[keyof T]
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key as keyof T] = this.sanitizeObject(value) as T[keyof T]
      } else {
        sanitized[key as keyof T] = value
      }
    }
    
    return sanitized
  }
  
  static validateAndSanitize<T>(data: unknown, schema: z.ZodSchema<T>): T {
    // D'abord sanitizer
    const sanitized = typeof data === 'object' && data !== null 
      ? this.sanitizeObject(data as Record<string, any>)
      : data
    
    // Puis valider
    const result = schema.safeParse(sanitized)
    
    if (!result.success) {
      throw new ValidationError('Donn√©es invalides', result.error.issues)
    }
    
    return result.data
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public issues: z.ZodIssue[]
  ) {
    super(message)
    this.name = 'ValidationError'
  }
}
```

### **√âTAPE 5.2 : Chiffrement et S√©curit√© des Donn√©es**

**`src/utils/security.ts`**
```typescript
import CryptoJS from 'crypto-js'

export class SecurityManager {
  private static instance: SecurityManager
  private keyCache = new Map<string, CryptoJS.lib.WordArray>()
  private readonly algorithm = CryptoJS.AES
  
  static getInstance(): SecurityManager {
    if (!SecurityManager.instance) {
      SecurityManager.instance = new SecurityManager()
    }
    return SecurityManager.instance
  }
  
  // G√©n√©ration de cl√© s√©curis√©e
  private generateSecureKey(): string {
    const array = new Uint8Array(32)
    crypto.getRandomValues(array)
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
  }
  
  // D√©rivation de cl√© avec PBKDF2
  private deriveKey(password: string, salt: CryptoJS.lib.WordArray): CryptoJS.lib.WordArray {
    const cacheKey = password + salt.toString()
    
    if (this.keyCache.has(cacheKey)) {
      return this.keyCache.get(cacheKey)!
    }
    
    const key = CryptoJS.PBKDF2(password, salt, {
      keySize: 256 / 32,
      iterations: 10000,
      hasher: CryptoJS.algo.SHA256
    })
    
    this.keyCache.set(cacheKey, key)
    return key
  }
  
  // Chiffrement AES-256-GCM
  encrypt(data: string, password?: string): string {
    try {
      const key = password || this.generateSecureKey()
      const salt = CryptoJS.lib.WordArray.random(256 / 8)
      const iv = CryptoJS.lib.WordArray.random(96 / 8)
      
      const derivedKey = this.deriveKey(key, salt)
      
      const encrypted = this.algorithm.encrypt(data, derivedKey, {
        iv: iv,
        mode: CryptoJS.mode.GCM,
        padding: CryptoJS.pad.NoPadding
      })
      
      // Combiner salt + iv + donn√©es chiffr√©es
      const combined = salt.toString() + ':' + iv.toString() + ':' + encrypted.toString()
      
      return btoa(combined)
    } catch (error) {
      console.error('Encryption failed:', error)
      throw new Error('√âchec du chiffrement')
    }
  }
  
  // D√©chiffrement AES-256-GCM
  decrypt(encryptedData: string, password: string): string {
    try {
      const decoded = atob(encryptedData)
      const parts = decoded.split(':')
      
      if (parts.length !== 3) {
        throw new Error('Format de donn√©es chiffr√©es invalide')
      }
      
      const salt = CryptoJS.enc.Hex.parse(parts[0])
      const iv = CryptoJS.enc.Hex.parse(parts[1])
      const encrypted = parts[2]
      
      const derivedKey = this.deriveKey(password, salt)
      
      const decrypted = this.algorithm.decrypt(encrypted, derivedKey, {
        iv: iv,
        mode: CryptoJS.mode.GCM,
        padding: CryptoJS.pad.NoPadding
      })
      
      return decrypted.toString(CryptoJS.enc.Utf8)
    } catch (error) {
      console.error('Decryption failed:', error)
      throw new Error('√âchec du d√©chiffrement')
    }
  }
  
  // Hachage s√©curis√©
  hash(data: string): string {
    return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex)
  }
  
  // G√©n√©ration de token s√©curis√©
  generateSecureToken(length: number = 32): string {
    const array = new Uint8Array(length)
    crypto.getRandomValues(array)
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('')
  }
  
  // V√©rification d'int√©grit√©
  verifyIntegrity(data: string, hash: string): boolean {
    return this.hash(data) === hash
  }
  
  // Nettoyage du cache (important pour la s√©curit√©)
  clearKeyCache(): void {
    this.keyCache.clear()
  }
}

// Gestionnaire de stockage s√©curis√©
export class SecureStorage {
  private security = SecurityManager.getInstance()
  private userKey: string | null = null
  
  // Initialiser avec le mot de passe utilisateur
  initialize(userPassword: string): void {
    this.userKey = this.security.hash(userPassword)
  }
  
  // Stocker des donn√©es sensibles
  setSecure(key: string, data: any): void {
    if (!this.userKey) {
      throw new Error('SecureStorage non initialis√©')
    }
    
    try {
      const serialized = JSON.stringify(data)
      const encrypted = this.security.encrypt(serialized, this.userKey)
      const timestamp = Date.now()
      
      const payload = {
        data: encrypted,
        timestamp,
        integrity: this.security.hash(encrypted + timestamp)
      }
      
      localStorage.setItem(`secure_${key}`, JSON.stringify(payload))
    } catch (error) {
      console.error('Secure storage failed:', error)
      throw new Error('√âchec du stockage s√©curis√©')
    }
  }
  
  // R√©cup√©rer des donn√©es sensibles
  getSecure<T>(key: string): T | null {
    if (!this.userKey) {
      throw new Error('SecureStorage non initialis√©')
    }
    
    try {
      const stored = localStorage.getItem(`secure_${key}`)
      if (!stored) return null
      
      const payload = JSON.parse(stored)
      
      // V√©rifier l'int√©grit√©
      const expectedIntegrity = this.security.hash(payload.data + payload.timestamp)
      if (payload.integrity !== expectedIntegrity) {
        console.warn('Integrity check failed for:', key)
        this.removeSecure(key)
        return null
      }
      
      // V√©rifier l'expiration (optionnel)
      const age = Date.now() - payload.timestamp
      if (age > 24 * 60 * 60 * 1000) { // 24h
        this.removeSecure(key)
        return null
      }
      
      const decrypted = this.security.decrypt(payload.data, this.userKey)
      return JSON.parse(decrypted)
    } catch (error) {
      console.error('Secure retrieval failed:', error)
      this.removeSecure(key)
      return null
    }
  }
  
  // Supprimer des donn√©es s√©curis√©es
  removeSecure(key: string): void {
    localStorage.removeItem(`secure_${key}`)
  }
  
  // Nettoyer toutes les donn√©es s√©curis√©es
  clearAll(): void {
    const keys = Object.keys(localStorage)
    keys.forEach(key => {
      if (key.startsWith('secure_')) {
        localStorage.removeItem(key)
      }
    })
    this.security.clearKeyCache()
  }
}

// Rate Limiter pour pr√©venir les attaques
export class RateLimiter {
  private attempts = new Map<string, number[]>()
  private readonly maxAttempts: number
  private readonly windowMs: number
  private readonly blockDurationMs: number
  
  constructor(
    maxAttempts: number = 30,
    windowMs: number = 60000,
    blockDurationMs: number = 300000
  ) {
    this.maxAttempts = maxAttempts
    this.windowMs = windowMs
    this.blockDurationMs = blockDurationMs
  }
  
  // V√©rifier si l'action est autoris√©e
  isAllowed(identifier: string): boolean {
    const now = Date.now()
    const attempts = this.attempts.get(identifier) || []
    
    // Nettoyer les tentatives anciennes
    const recentAttempts = attempts.filter(time => now - time < this.windowMs)
    this.attempts.set(identifier, recentAttempts)
    
    // V√©rifier le blocage
    if (recentAttempts.length >= this.maxAttempts) {
      const firstAttempt = recentAttempts[0]
      if (now - firstAttempt < this.blockDurationMs) {
        return false
      }
      // D√©bloquer apr√®s la p√©riode de blocage
      this.attempts.delete(identifier)
      return true
    }
    
    return true
  }
  
  // Enregistrer une tentative
  recordAttempt(identifier: string): void {
    const attempts = this.attempts.get(identifier) || []
    attempts.push(Date.now())
    this.attempts.set(identifier, attempts)
  }
  
  // R√©initialiser les tentatives pour un identifiant
  reset(identifier: string): void {
    this.attempts.delete(identifier)
  }
  
  // Obtenir le temps restant avant d√©blocage
  getTimeUntilUnblock(identifier: string): number {
    const attempts = this.attempts.get(identifier) || []
    if (attempts.length < this.maxAttempts) return 0
    
    const firstAttempt = attempts[0]
    const timeElapsed = Date.now() - firstAttempt
    return Math.max(0, this.blockDurationMs - timeElapsed)
  }
}

// Auditeur de s√©curit√©
export class SecurityAuditor {
  private static instance: SecurityAuditor
  private audits: SecurityAudit[] = []
  private rateLimiter = new RateLimiter()
  
  static getInstance(): SecurityAuditor {
    if (!SecurityAuditor.instance) {
      SecurityAuditor.instance = new SecurityAuditor()
    }
    return SecurityAuditor.instance
  }
  
  // Enregistrer un √©v√©nement de s√©curit√©
  logSecurityEvent(
    type: SecurityEventType,
    severity: SecuritySeverity,
    message: string,
    context?: Record<string, any>
  ): void {
    const audit: SecurityAudit = {
      id: crypto.randomUUID(),
      type,
      severity,
      message,
      timestamp: new Date(),
      userId: context?.userId,
      ip: context?.ip,
      userAgent: navigator.userAgent
    }
    
    this.audits.push(audit)
    
    // Limiter la taille des logs
    if (this.audits.length > 1000) {
      this.audits = this.audits.slice(-500)
    }
    
    // Alertes pour √©v√©nements critiques
    if (severity === SecuritySeverity.CRITICAL) {
      this.handleCriticalAlert(audit)
    }
    
    console.warn('üîí Security Event:', audit)
  }
  
  // Analyser les tentatives d'attaque
  analyzeInput(input: string, context: string): void {
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+=/i,
      /eval\(/i,
      /function\(/i,
      /\.\.\/\.\.\//,
      /union.*select/i,
      /drop.*table/i
    ]
    
    const detected = suspiciousPatterns.find(pattern => pattern.test(input))
    
    if (detected) {
      this.logSecurityEvent(
        SecurityEventType.XSS_ATTEMPT,
        SecuritySeverity.HIGH,
        `Tentative d'injection d√©tect√©e dans ${context}`,
        { input: input.substring(0, 100), pattern: detected.toString() }
      )
    }
  }
  
  // V√©rifier le rate limiting
  checkRateLimit(identifier: string, action: string): boolean {
    if (!this.rateLimiter.isAllowed(identifier)) {
      this.logSecurityEvent(
        SecurityEventType.RATE_LIMIT_EXCEEDED,
        SecuritySeverity.MEDIUM,
        `Rate limit d√©pass√© pour ${action}`,
        { identifier }
      )
      return false
    }
    
    this.rateLimiter.recordAttempt(identifier)
    return true
  }
  
  // G√©rer les alertes critiques
  private handleCriticalAlert(audit: SecurityAudit): void {
    // En production, envoyer √† un service de monitoring
    console.error('üö® CRITICAL SECURITY ALERT:', audit)
    
    // Optionnel: Bloquer l'utilisateur temporairement
    if (audit.userId) {
      localStorage.setItem(`blocked_${audit.userId}`, Date.now().toString())
    }
  }
  
  // Obtenir les audits r√©cents
  getRecentAudits(limit: number = 50): SecurityAudit[] {
    return this.audits.slice(-limit)
  }
  
  // Statistiques de s√©curit√©
  getSecurityStats(): {
    totalEvents: number
    criticalEvents: number
    recentEvents: number
  } {
    const now = Date.now()
    const recentThreshold = now - (24 * 60 * 60 * 1000) // 24h
    
    return {
      totalEvents: this.audits.length,
      criticalEvents: this.audits.filter(a => a.severity === SecuritySeverity.CRITICAL).length,
      recentEvents: this.audits.filter(a => a.timestamp.getTime() > recentThreshold).length
    }
  }
}
```

### **√âTAPE 5.3 : Headers de S√©curit√© et CSP**

**`index.html`** (mise √† jour)
```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Headers de s√©curit√© -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    img-src 'self' data: blob: https:;
    connect-src 'self' https://api.mathilde-fleurs.com;
    media-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
  ">
  
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <meta http-equiv="Permissions-Policy" content="
    camera=(),
    microphone=(),
    geolocation=(),
    payment=(),
    usb=(),
    bluetooth=()
  ">
  
  <!-- PWA Meta -->
  <meta name="theme-color" content="#10b981">
  <meta name="background_color" content="#ffffff">
  <meta name="display" content="standalone">
  <meta name="orientation" content="portrait">
  
  <!-- Ic√¥nes -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="manifest" href="/manifest.json">
  
  <!-- Fonts avec preload pour performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
  
  <title>Mathilde Fleurs - Gestion d'√âv√©nements</title>
  
  <!-- Preload des ressources critiques -->
  <link rel="preload" href="/src/main.tsx" as="script">
  <link rel="preload" href="/pwa-192x192.png" as="image">
</head>
<body>
  <div id="root"></div>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('‚úÖ SW registered:', registration.scope)
          })
          .catch(error => {
            console.error('‚ùå SW registration failed:', error)
          })
      })
    }
  </script>
  
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

---

## üé® PHASE 6 : UX/UI EXCELLENTE

### **√âTAPE 6.1 : Syst√®me de Th√®mes Avanc√©**

**`src/contexts/ThemeContext.tsx`**
```typescript
import React, { createContext, useContext, useEffect, useState, useCallback } from 'react'

export enum ThemeMode {
  LIGHT = 'light',
  DARK = 'dark',
  SYSTEM = 'system'
}

interface ThemeContextType {
  theme: ThemeMode
  isDark: boolean
  setTheme: (theme: ThemeMode) => void
  toggleTheme: () => void
  systemPreference: ThemeMode.LIGHT | ThemeMode.DARK
}

const ThemeContext = createContext<ThemeContextType | null>(null)

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setThemeState] = useState<ThemeMode>(() => {
    const stored = localStorage.getItem('mathilde-theme')
    return (stored as ThemeMode) || ThemeMode.SYSTEM
  })
  
  const [systemPreference, setSystemPreference] = useState<ThemeMode.LIGHT | ThemeMode.DARK>(
    window.matchMedia('(prefers-color-scheme: dark)').matches ? ThemeMode.DARK : ThemeMode.LIGHT
  )
  
  // Calculer le th√®me effectif
  const isDark = theme === ThemeMode.DARK || (theme === ThemeMode.SYSTEM && systemPreference === ThemeMode.DARK)
  
  // √âcouter les changements de pr√©f√©rence syst√®me
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    
    const handleChange = (e: MediaQueryListEvent) => {
      setSystemPreference(e.matches ? ThemeMode.DARK : ThemeMode.LIGHT)
    }
    
    mediaQuery.addEventListener('change', handleChange)
    return () => mediaQuery.removeEventListener('change', handleChange)
  }, [])
  
  // Appliquer le th√®me au DOM
  useEffect(() => {
    const root = document.documentElement
    
    if (isDark) {
      root.classList.add('dark')
      root.style.colorScheme = 'dark'
    } else {
      root.classList.remove('dark')
      root.style.colorScheme = 'light'
    }
    
    // Meta theme-color dynamique
    const metaThemeColor = document.querySelector('meta[name="theme-color"]')
    if (metaThemeColor) {
      metaThemeColor.setAttribute('content', isDark ? '#1f2937' : '#10b981')
    }
  }, [isDark])
  
  const setTheme = useCallback((newTheme: ThemeMode) => {
    setThemeState(newTheme)
    localStorage.setItem('mathilde-theme', newTheme)
  }, [])
  
  const toggleTheme = useCallback(() => {
    setTheme(isDark ? ThemeMode.LIGHT : ThemeMode.DARK)
  }, [isDark, setTheme])
  
  const value = {
    theme,
    isDark,
    setTheme,
    toggleTheme,
    systemPreference
  }
  
  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

### **√âTAPE 6.2 : Composants UI avec Animations**

**`src/components/ui/Button.tsx`**
```typescript
import React, { forwardRef } from 'react'
import { motion, MotionProps } from 'framer-motion'
import { clsx } from 'clsx'
import { Loader2 } from 'lucide-react'

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  isLoading?: boolean
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
  animation?: MotionProps
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(({
  children,
  className,
  variant = 'primary',
  size = 'md',
  isLoading = false,
  leftIcon,
  rightIcon,
  disabled,
  animation,
  ...props
}, ref) => {
  const baseClasses = [
    'inline-flex items-center justify-center font-medium rounded-lg',
    'transition-all duration-200 ease-in-out',
    'focus:outline-none focus:ring-2 focus:ring-offset-2',
    'disabled:opacity-50 disabled:cursor-not-allowed',
    'active:scale-95'
  ]
  
  const variants = {
    primary: [
      'bg-primary-500 hover:bg-primary-600 text-white',
      'focus:ring-primary-500 dark:focus:ring-primary-400',
      'shadow-lg hover:shadow-xl'
    ],
    secondary: [
      'bg-gray-100 hover:bg-gray-200 text-gray-900',
      'dark:bg-gray-800 dark:hover:bg-gray-700 dark:text-gray-100',
      'focus:ring-gray-500'
    ],
    outline: [
      'border-2 border-primary-500 text-primary-500 hover:bg-primary-500 hover:text-white',
      'dark:border-primary-400 dark:text-primary-400 dark:hover:bg-primary-400 dark:hover:text-gray-900',
      'focus:ring-primary-500'
    ],
    ghost: [
      'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-800',
      'focus:ring-gray-500'
    ],
    danger: [
      'bg-red-500 hover:bg-red-600 text-white',
      'focus:ring-red-500 shadow-lg hover:shadow-xl'
    ]
  }
  
  const sizes = {
    sm: 'px-3 py-1.5 text-sm gap-1.5',
    md: 'px-4 py-2 text-sm gap-2',
    lg: 'px-6 py-3 text-base gap-2'
  }
  
  const iconSizes = {
    sm: 'w-3 h-3',
    md: 'w-4 h-4',
    lg: 'w-5 h-5'
  }
  
  const classes = clsx(
    baseClasses,
    variants[variant],
    sizes[size],
    className
  )
  
  const defaultAnimation: MotionProps = {
    whileHover: { scale: disabled ? 1 : 1.02 },
    whileTap: { scale: disabled ? 1 : 0.98 },
    transition: { type: "spring", stiffness: 400, damping: 17 }
  }
  
  return (
    <motion.button
      ref={ref}
      className={classes}
      disabled={disabled || isLoading}
      {...defaultAnimation}
      {...animation}
      {...props}
    >
      {isLoading ? (
        <Loader2 className={clsx(iconSizes[size], 'animate-spin')} />
      ) : leftIcon ? (
        <span className={iconSizes[size]}>{leftIcon}</span>
      ) : null}
      
      {children}
      
      {rightIcon && !isLoading && (
        <span className={iconSizes[size]}>{rightIcon}</span>
      )}
    </motion.button>
  )
})

Button.displayName = 'Button'

export default Button
```

**`src/components/ui/Input.tsx`**
```typescript
import React, { forwardRef, useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { clsx } from 'clsx'
import { Eye, EyeOff, AlertCircle } from 'lucide-react'

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
  hint?: string
  leftIcon?: React.ReactNode
  rightIcon?: React.ReactNode
  variant?: 'default' | 'filled'
  showPasswordToggle?: boolean
}

const Input = forwardRef<HTMLInputElement, InputProps>(({
  className,
  type,
  label,
  error,
  hint,
  leftIcon,
  rightIcon,
  variant = 'default',
  showPasswordToggle = false,
  disabled,
  ...props
}, ref) => {
  const [showPassword, setShowPassword] = useState(false)
  const [isFocused, setIsFocused] = useState(false)
  
  const inputType = type === 'password' && showPassword ? 'text' : type
  
  const containerClasses = clsx(
    'relative w-full'
  )
  
  const inputClasses = clsx(
    'w-full px-3 py-2 text-sm border rounded-lg transition-all duration-200',
    'focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent',
    'disabled:opacity-50 disabled:cursor-not-allowed',
    leftIcon && 'pl-10',
    (rightIcon || showPasswordToggle || error) && 'pr-10',
    {
      // Variant default
      'bg-white border-gray-300 text-gray-900 placeholder-gray-500': variant === 'default' && !error,
      'dark:bg-gray-800 dark:border-gray-600 dark:text-gray-100 dark:placeholder-gray-400': variant === 'default' && !error,
      
      // Variant filled
      'bg-gray-50 border-transparent text-gray-900 placeholder-gray-500': variant === 'filled' && !error,
      'dark:bg-gray-900 dark:text-gray-100 dark:placeholder-gray-400': variant === 'filled' && !error,
      
      // Error state
      'border-red-300 text-red-900 placeholder-red-300': error,
      'focus:ring-red-500 focus:border-red-500': error,
      'dark:border-red-600 dark:text-red-100': error,
    },
    className
  )
  
  const labelClasses = clsx(
    'block text-sm font-medium mb-1 transition-colors duration-200',
    error ? 'text-red-700 dark:text-red-400' : 'text-gray-700 dark:text-gray-300',
    isFocused && !error && 'text-primary-600 dark:text-primary-400'
  )
  
  return (
    <div className={containerClasses}>
      {label && (
        <motion.label
          className={labelClasses}
          animate={{ scale: isFocused ? 1.02 : 1 }}
          transition={{ type: "spring", stiffness: 300, damping: 30 }}
        >
          {label}
        </motion.label>
      )}
      
      <div className="relative">
        {leftIcon && (
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <span className={clsx(
              'w-4 h-4 transition-colors duration-200',
              error ? 'text-red-400' : 'text-gray-400',
              isFocused && !error && 'text-primary-500'
            )}>
              {leftIcon}
            </span>
          </div>
        )}
        
        <motion.input
          ref={ref}
          type={inputType}
          className={inputClasses}
          disabled={disabled}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          whileFocus={{ scale: 1.01 }}
          transition={{ type: "spring", stiffness: 300, damping: 30 }}
          {...props}
        />
        
        <div className="absolute inset-y-0 right-0 flex items-center pr-3">
          {error && (
            <AlertCircle className="w-4 h-4 text-red-400" />
          )}
          
          {showPasswordToggle && type === 'password' && (
            <button
              type="button"
              onClick={() => setShowPassword(!showPassword)}
              className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
            >
              {showPassword ? (
                <EyeOff className="w-4 h-4" />
              ) : (
                <Eye className="w-4 h-4" />
              )}
            </button>
          )}
          
          {rightIcon && !error && !showPasswordToggle && (
            <span className={clsx(
              'w-4 h-4 transition-colors duration-200',
              isFocused ? 'text-primary-500' : 'text-gray-400'
            )}>
              {rightIcon}
            </span>
          )}
        </div>
      </div>
      
      <AnimatePresence mode="wait">
        {error && (
          <motion.p
            initial={{ opacity: 0, y: -10, height: 0 }}
            animate={{ opacity: 1, y: 0, height: 'auto' }}
            exit={{ opacity: 0, y: -10, height: 0 }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </motion.p>
        )}
        
        {hint && !error && (
          <motion.p
            initial={{ opacity: 0, y: -10, height: 0 }}
            animate={{ opacity: 1, y: 0, height: 'auto' }}
            exit={{ opacity: 0, y: -10, height: 0 }}
            className="mt-1 text-xs text-gray-500 dark:text-gray-400"
          >
            {hint}
          </motion.p>
        )}
      </AnimatePresence>
    </div>
  )
})

Input.displayName = 'Input'

export default Input
```

### **√âTAPE 6.3 : Layout Responsive Complet**

**`src/components/layout/Layout.tsx`**
```typescript
import React, { useState, useEffect } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { 
  Menu, X, Search, Bell, Settings, User, LogOut,
  Calendar, Users, Flower, BarChart3, Home
} from 'lucide-react'
import { useTheme } from '@/contexts/ThemeContext'
import { useViewport } from '@/hooks/usePerformance'
import Button from '@/components/ui/Button'
import OfflineIndicator from '@/components/PWA/OfflineIndicator'
import InstallPrompt from '@/components/PWA/InstallPrompt'

interface LayoutProps {
  children: React.ReactNode
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [searchOpen, setSearchOpen] = useState(false)
  const { isDark, toggleTheme } = useTheme()
  const { width } = useViewport()
  
  const isMobile = width < 768
  const isTablet = width >= 768 && width < 1024
  
  // Navigation items
  const navigation = [
    { name: 'Accueil', href: '/', icon: Home, current: true },
    { name: 'Calendrier', href: '/calendar', icon: Calendar, current: false },
    { name: '√âv√©nements', href: '/events', icon: Flower, current: false },
    { name: 'Clients', href: '/clients', icon: Users, current: false },
    { name: 'Statistiques', href: '/stats', icon: BarChart3, current: false },
  ]
  
  // Fermer la sidebar sur mobile quand on navigue
  useEffect(() => {
    if (isMobile) {
      setSidebarOpen(false)
    }
  }, [isMobile])
  
  const sidebarVariants = {
    open: {
      x: 0,
      transition: {
        type: "spring",
        stiffness: 300,
        damping: 30
      }
    },
    closed: {
      x: isMobile ? "-100%" : "-240px",
      transition: {
        type: "spring",
        stiffness: 300,
        damping: 30
      }
    }
  }
  
  const overlayVariants = {
    open: { opacity: 1 },
    closed: { opacity: 0 }
  }
  
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
      {/* PWA Components */}
      <OfflineIndicator />
      <InstallPrompt />
      
      {/* Mobile sidebar overlay */}
      <AnimatePresence>
        {sidebarOpen && isMobile && (
          <motion.div
            initial="closed"
            animate="open"
            exit="closed"
            variants={overlayVariants}
            className="fixed inset-0 z-40 bg-black bg-opacity-50"
            onClick={() => setSidebarOpen(false)}
          />
        )}
      </AnimatePresence>
      
      {/* Sidebar */}
      <motion.aside
        initial={isMobile ? "closed" : "open"}
        animate={sidebarOpen || !isMobile ? "open" : "closed"}
        variants={sidebarVariants}
        className={clsx(
          "fixed top-0 left-0 bottom-0 z-50 w-60 bg-white dark:bg-gray-800",
          "border-r border-gray-200 dark:border-gray-700",
          "flex flex-col shadow-lg"
        )}
      >
        {/* Sidebar Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center space-x-2">
            <div className="w-8 h-8 bg-primary-500 rounded-lg flex items-center justify-center">
              <Flower className="w-5 h-5 text-white" />
            </div>
            <span className="font-semibold text-gray-900 dark:text-white">
              Mathilde Fleurs
            </span>
          </div>
          
          {isMobile && (
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setSidebarOpen(false)}
              leftIcon={<X className="w-4 h-4" />}
            />
          )}
        </div>
        
        {/* Navigation */}
        <nav className="flex-1 px-4 py-4 space-y-2 overflow-y-auto">
          {navigation.map((item) => (
            <motion.a
              key={item.name}
              href={item.href}
              whileHover={{ scale: 1.02, x: 4 }}
              whileTap={{ scale: 0.98 }}
              className={clsx(
                'flex items-center space-x-3 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200',
                item.current
                  ? 'bg-primary-50 text-primary-700 dark:bg-primary-900/20 dark:text-primary-300'
                  : 'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
              )}
            >
              <item.icon className="w-5 h-5 flex-shrink-0" />
              <span>{item.name}</span>
            </motion.a>
          ))}
        </nav>
        
        {/* Sidebar Footer */}
        <div className="p-4 border-t border-gray-200 dark:border-gray-700">
          <div className="flex items-center space-x-3 mb-3">
            <div className="w-8 h-8 bg-gray-300 rounded-full flex items-center justify-center">
              <User className="w-4 h-4 text-gray-600" />
            </div>
            <div className="flex-1 min-w-0">
              <p className="text-sm font-medium text-gray-900 dark:text-white truncate">
                Mathilde Dupont
              </p>
              <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                mathilde@fleurs.com
              </p>
            </div>
          </div>
          
          <div className="flex space-x-2">
            <Button
              variant="ghost"
              size="sm"
              onClick={toggleTheme}
              className="flex-1"
              leftIcon={isDark ? 'üåû' : 'üåô'}
            >
              {isDark ? 'Clair' : 'Sombre'}
            </Button>
            
            <Button
              variant="ghost"
              size="sm"
              leftIcon={<Settings className="w-4 h-4" />}
            />
          </div>
        </div>
      </motion.aside>
      
      {/* Main Content */}
      <div className={clsx(
        "transition-all duration-300",
        isMobile ? "ml-0" : "ml-60"
      )}>
        {/* Top Bar */}
        <header className="sticky top-0 z-30 bg-white/80 dark:bg-gray-800/80 backdrop-blur-lg border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between px-4 py-3">
            {/* Left Section */}
            <div className="flex items-center space-x-4">
              {isMobile && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setSidebarOpen(true)}
                  leftIcon={<Menu className="w-5 h-5" />}
                />
              )}
              
              <div className="hidden md:block">
                <h1 className="text-lg font-semibold text-gray-900 dark:text-white">
                  Tableau de bord
                </h1>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  G√©rez vos √©v√©nements et clients
                </p>
              </div>
            </div>
            
            {/* Right Section */}
            <div className="flex items-center space-x-2">
              {/* Search */}
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setSearchOpen(true)}
                leftIcon={<Search className="w-4 h-4" />}
                className="hidden sm:flex"
              >
                Rechercher
              </Button>
              
              {/* Notifications */}
              <Button
                variant="ghost"
                size="sm"
                leftIcon={<Bell className="w-4 h-4" />}
              />
              
              {/* User Menu */}
              <Button
                variant="ghost"
                size="sm"
                leftIcon={<User className="w-4 h-4" />}
              />
            </div>
          </div>
        </header>
        
        {/* Page Content */}
        <main className="flex-1 p-4 md:p-6 lg:p-8">
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
            className="max-w-7xl mx-auto"
          >
            {children}
          </motion.div>
        </main>
      </div>
      
      {/* Search Modal */}
      <AnimatePresence>
        {searchOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 bg-black/50 flex items-start justify-center pt-20"
            onClick={() => setSearchOpen(false)}
          >
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.9, opacity: 0 }}
              onClick={(e) => e.stopPropagation()}
              className="w-full max-w-lg mx-4 bg-white dark:bg-gray-800 rounded-xl shadow-2xl"
            >
              <div className="p-4">
                <div className="flex items-center space-x-3">
                  <Search className="w-5 h-5 text-gray-400" />
                  <input
                    type="text"
                    placeholder="Rechercher des √©v√©nements, clients..."
                    className="flex-1 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 focus:outline-none"
                    autoFocus
                  />
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setSearchOpen(false)}
                  >
                    √âchap
                  </Button>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

export default Layout